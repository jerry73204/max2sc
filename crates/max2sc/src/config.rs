//! Configuration generation and management

use eyre::Result;
use std::fs;
use std::path::Path;
use tracing::{info, warn};

/// Configuration file generator
pub struct ConfigGenerator;

impl ConfigGenerator {
    /// Generate example configuration files
    pub fn generate_examples<P: AsRef<Path>>(output_dir: P) -> Result<()> {
        let output_dir = output_dir.as_ref();

        info!(
            "Generating example configuration files in: {}",
            output_dir.display()
        );

        // Create output directory if it doesn't exist
        fs::create_dir_all(output_dir)?;

        // Generate speaker configuration example
        Self::generate_speaker_config_example(output_dir)?;

        // Generate conversion options example
        Self::generate_conversion_config_example(output_dir)?;

        // Generate project template
        Self::generate_project_template(output_dir)?;

        info!("âœ“ Example configuration files generated");
        Ok(())
    }

    /// Generate example speaker configuration file
    fn generate_speaker_config_example<P: AsRef<Path>>(output_dir: P) -> Result<()> {
        let file_path = output_dir.as_ref().join("example_speakers.txt");

        let content = r#"# Example speaker configuration file for max2sc
# Format: OSC-style speaker definitions with AED coordinates
# A = Azimuth (degrees), E = Elevation (degrees), D = Distance (meters)

# Stereo setup
/speakers/1 aed 0. 0. 2.
/speakers/2 aed 180. 0. 2.

# Quadrophonic setup
/speakers/3 aed 45. 0. 2.
/speakers/4 aed 135. 0. 2.
/speakers/5 aed 225. 0. 2.
/speakers/6 aed 315. 0. 2.

# 8-channel circle
/speakers/7 aed 0. 0. 3.
/speakers/8 aed 45. 0. 3.
/speakers/9 aed 90. 0. 3.
/speakers/10 aed 135. 0. 3.
/speakers/11 aed 180. 0. 3.
/speakers/12 aed 225. 0. 3.
/speakers/13 aed 270. 0. 3.
/speakers/14 aed 315. 0. 3.

# Additional parameters
/speakers/delay 0. 0. 0. 0. 0. 0. 0. 0.
/speakers/gain 1. 1. 1. 1. 1. 1. 1. 1.
"#;

        fs::write(&file_path, content)?;
        info!("Created example speaker config: {}", file_path.display());
        Ok(())
    }

    /// Generate conversion configuration example
    fn generate_conversion_config_example<P: AsRef<Path>>(output_dir: P) -> Result<()> {
        let file_path = output_dir.as_ref().join("max2sc_config.yaml");

        let content = r#"# max2sc conversion configuration
# This file controls how Max objects are converted to SuperCollider

# Global settings
project:
  name: "Converted_Max_Project"
  author: "max2sc"
  version: "1.0.0"
  sc_version: "3.13"

# Audio settings
audio:
  sample_rate: 48000
  buffer_size: 512
  input_channels: 2
  output_channels: 8

# Conversion options
conversion:
  skip_spatial: false
  skip_multichannel: false
  generate_osc: true
  simplified_mappings: false
  preserve_max_ids: true

# Object mapping overrides
mappings:
  # Override default object conversions
  "dac~": "Out.ar"
  "adc~": "SoundIn.ar"
  "pan~": "Pan2.ar"
  
# Bus configuration
buses:
  main_out: 0
  aux_sends: [2, 4, 6]
  control_buses: 10

# OSC settings
osc:
  port: 57120
  host: "localhost"
  generate_responders: true
  preserve_namespaces: true

# Spatial audio settings
spatial:
  default_distance: 2.0
  ambisonics_order: 3
  use_atk: true
  speaker_array: "8ch_circle"
"#;

        fs::write(&file_path, content)?;
        info!("Created conversion config: {}", file_path.display());
        Ok(())
    }

    /// Generate project template structure
    fn generate_project_template<P: AsRef<Path>>(output_dir: P) -> Result<()> {
        let template_dir = output_dir.as_ref().join("project_template");

        // Create directory structure
        fs::create_dir_all(&template_dir)?;
        fs::create_dir_all(template_dir.join("lib"))?;
        fs::create_dir_all(template_dir.join("config"))?;
        fs::create_dir_all(template_dir.join("sounds"))?;
        fs::create_dir_all(template_dir.join("data"))?;

        // Create README
        let readme_content = r#"# SuperCollider Project Template

This is a template structure for projects converted from Max MSP using max2sc.

## Directory Structure

- `lib/` - SynthDefs and utility functions
- `config/` - Configuration files (buses, speakers, etc.)
- `sounds/` - Audio files
- `data/` - Data files and presets
- `main.scd` - Main project file

## Usage

1. Open `main.scd` in SuperCollider
2. Evaluate the code to load the project
3. Adjust configuration files as needed
4. Replace placeholder audio files in `sounds/`

## Generated by max2sc

This project was generated by the max2sc converter.
For more information, see: https://github.com/your-org/max2sc
"#;

        fs::write(template_dir.join("README.md"), readme_content)?;

        // Create main.scd template
        let main_content = r#"(
// Main project file - generated by max2sc
// Load this file to initialize the converted Max project

// Boot server if needed
s.waitForBoot({
    "Loading converted Max project...".postln;
    
    // Load configuration
    "config/project_config.scd".resolveRelative.load;
    
    // Load SynthDefs
    "lib/SynthDefs.scd".resolveRelative.load;
    
    // Set up buses and routing
    "lib/setup.scd".resolveRelative.load;
    
    // Start OSC responders
    "lib/osc_responders.scd".resolveRelative.load;
    
    "Project loaded successfully!".postln;
});
)
"#;

        fs::write(template_dir.join("main.scd"), main_content)?;

        info!("Created project template: {}", template_dir.display());
        Ok(())
    }

    /// Load configuration from file if it exists
    pub fn _load_config<P: AsRef<Path>>(config_path: P) -> Result<Option<ProjectConfig>> {
        let config_path = config_path.as_ref();

        if !config_path.exists() {
            return Ok(None);
        }

        let _content = fs::read_to_string(config_path)?;

        // Basic YAML-like parsing (simplified for now)
        // In a real implementation, you'd use serde_yaml
        warn!("Configuration file parsing not fully implemented yet");

        Ok(Some(ProjectConfig::default()))
    }
}

/// Project configuration structure
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct ProjectConfig {
    pub project_name: String,
    pub author: String,
    pub version: String,
    pub sc_version: String,
    pub sample_rate: u32,
    pub buffer_size: u32,
    pub input_channels: u8,
    pub output_channels: u8,
}

impl Default for ProjectConfig {
    fn default() -> Self {
        Self {
            project_name: "Converted_Max_Project".to_string(),
            author: "max2sc".to_string(),
            version: "1.0.0".to_string(),
            sc_version: "3.13".to_string(),
            sample_rate: 48000,
            buffer_size: 512,
            input_channels: 2,
            output_channels: 8,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_generate_examples() -> Result<()> {
        let temp_dir = TempDir::new()?;

        ConfigGenerator::generate_examples(temp_dir.path())?;

        // Check that files were created
        assert!(temp_dir.path().join("example_speakers.txt").exists());
        assert!(temp_dir.path().join("max2sc_config.yaml").exists());
        assert!(temp_dir.path().join("project_template").is_dir());
        assert!(temp_dir.path().join("project_template/main.scd").exists());
        assert!(temp_dir.path().join("project_template/README.md").exists());

        Ok(())
    }

    #[test]
    fn test_speaker_config_content() -> Result<()> {
        let temp_dir = TempDir::new()?;

        ConfigGenerator::generate_speaker_config_example(temp_dir.path())?;

        let content = fs::read_to_string(temp_dir.path().join("example_speakers.txt"))?;
        assert!(content.contains("/speakers/1"));
        assert!(content.contains("aed"));
        assert!(content.contains("# Example speaker"));

        Ok(())
    }
}
